// Purpose: Defines the contract for the Unit of Work pattern in the Application Layer.
// This allows the application services/handlers to manage transactions and save changes
// without directly depending on the Infrastructure layer's DbContext.

using Microsoft.EntityFrameworkCore.Storage; // For IDbContextTransaction
using System; // For IAsyncDisposable
using System.Threading;
using System.Threading.Tasks;

namespace EcommercePlatform.Application.Interfaces.Common;

//This is the interface that the application layer will use to interact with the DbContext.
// It all got a bit more complicated because of a circular reference. This i have to work my way around it.
//The comments below are autogenerated by Rider - I left it here for reference. Why and what - I don't know. YEt'

public interface IUnitOfWork : IAsyncDisposable
{
    /// <summary>
    /// Begins a new database transaction.
    /// </summary>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the <see cref="IDbContextTransaction"/>.</returns>
    Task<IDbContextTransaction> BeginTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Commits the specified database transaction.
    /// </summary>
    /// <param name="transaction">The transaction to commit.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    Task CommitTransactionAsync(IDbContextTransaction transaction, CancellationToken cancellationToken = default);

    /// <summary>
    /// Rolls back the specified database transaction.
    /// </summary>
    /// <param name="transaction">The transaction to roll back.</param>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    Task RollbackTransactionAsync(IDbContextTransaction transaction, CancellationToken cancellationToken = default);

    /// <summary>
    /// Saves all changes made in this context to the database.
    /// </summary>
    /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>
    /// A task that represents the asynchronous save operation. The task result contains the
    /// number of state entries written to the database.
    /// </returns>
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

    // All this is because of a circular reference, because I wanted to split up the solution into little projects
    //
    // This can centralize repository access but also make the IUnitOfWork interface larger.
    
    // and inject repositories directly into handlers.
    //
    // IListingRepository Listings { get; }
    // IOrderRepository Orders { get; }
    // IUserRepository Users { get; }
    // IReviewRepository Reviews { get; }
}